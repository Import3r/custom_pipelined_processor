1- ALU
	a. 32-bit Adder
	b. And
	c. nor
	d. or
	e. comparator ?? (or use if statement)
	f. Shift left/right module
		*inputs: R[rt], shamt, left/right
		* output: R[rd]
	g. Subtract
3- Sign-extension module
4- instruction memory (uses 14-bit from 32-bit address)
5- Registers file
6- Data memory
7- Stages registers
8- Muxes
9- PC module (32-bit addresses)
10- Control unit
11- ALU control
----------------------
misc:
	add: 000011 01010 01011 01001 00000 100000 [D4B4820]
	sub: 000011 01010 01011 01001 00000 100100 [D4B4824]
	rs=10 t2 rt=11 t3 rd=9 t1
	000011 01001 01010 01000 00000 100000 add t0 t1 t2 [0d2a4020]
	000011 01000 01001 01001 00000 100100 sub t1 t0 t1 [0d094824]
	000011 01000 01001 01000 00000 100100 sub t0 t0 t1 [0d095824]
	
	001001 01010 01011 0000000000101000 [254b0028] I
	000010 00001001000011000001000010 [08243042] J
	
	000101 01000 01001 0000000000000010 beq
	000011 00000 01010 10001 00010 000000 sll t9,t2,2
	000011 00000 01010 10001 00010 000000

	000010 00000000000000000000111010 j[232]
	000111 00000000000000000000111010 jal[232]
	
	000011 00000 01001 10001 00001 000010 srl t9,t1,1
	000011 00000 10000 00000 00000 001000 jr t8
	000011 00000 01001 00000 00000 001000
	001001 10101 01111 000000000000101 addi t7,s3,5
	001100 10101 01111 000000000111111 and t7,s3,63
	
	000101 01001 01010 1111111111111110 beq t1,t2,224
	001111 00000 01111 0000000000001010
	010010 01001 01111 0000000000000000	lw t7,0(t1)
	010010 01001 01111 0000000000000000	lw t7,0(t1)
	000011 01001 01111 01010 00000 100001 lwn t7,t1,t2
	100010 01001 01111 0000000000000010 lbu t7,2(t1)
	sb t2,2(t1) 0xA12F0002
00000000 00000000 00000000 00000101
00001000 00000000 00000001 01010010
00000000 00000000 00001100 00000000
000000 00000 10011 0000000000000101
001001 00000 10011 0000000000000101
addi $s1,$0,5
001001 00000 10011 0000000000000101




001001 00000 10110 0000000000000010
addi $s4,$0,2

000101 00000 00000 0000000000001111
beq $0,$0,15

//Test for no forwarding
lw $t0,0($0)
nop
nop
addi $t0,$t0,2
andi $t0,$t0,2
sll $t0,$t0,2
srl $t0,$t0,1
nor $t0,$t0,1
nop
nop
sw $t0,0($0)
addi $t1,$0,6
addi $t2,$0,6
sub $t1,$t1,$t2
lwn $t2,$0,$t1
nop
nop
addi $t3,$t2,16
addi $t1,$0,2
addi $t2,$0,2
nop
nop
swn $t3, $t1,$t2
lbu $t4, 7($0)
add $t0,$t1,$t2
or $t0,$t0,$t1
and $t0,$t0,$t2

//Test for the forwarding
lw $t0,0($0)
addi $t0,$t0,2
andi $t0,$t0,2
sll $t0,$t0,2
srl $t0,$t0,1
nor $t0,$t0,1
sw $t0,0($0)
addi $t1,$0,6
addi $t2,$0,6
sub $t1,$t1,$t2
lwn $t2,$0,$t1
addi $t3,$t2,16
addi $t1,$0,2
addi $t2,$0,2
swn $t3, $t1,$t2
lbu $t4, 7($0)
add $t0,$t1,$t2
or $t0,$t0,$t1
and $t0,$t0,$t2





1- branch outcome in EXE with forwarding or not?
